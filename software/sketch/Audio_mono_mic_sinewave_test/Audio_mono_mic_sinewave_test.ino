#define MAX_BUFFER_SIZE 16
#define SAMPLING_FREQ 16000
#define LSB(n) ((n) & 255)
#define MSB(n) (((n) >> 8) & 255)
#define NOTE_POT A0
#include "notes.h"

const uint8_t sineTable[] = {
  0x80, 0x83, 0x86, 0x89, 0x8C, 0x8F, 0x92, 0x95, 0x98, 0x9B, 0x9E, 0xA2, 
  0xA5, 0xA7, 0xAA, 0xAD, 0xB0, 0xB3, 0xB6, 0xB9, 0xBC, 0xBE, 0xC1, 0xC4, 
  0xC6, 0xC9, 0xCB, 0xCE, 0xD0, 0xD3, 0xD5, 0xD7, 0xDA, 0xDC, 0xDE, 0xE0, 
  0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEB, 0xED, 0xEE, 0xF0, 0xF1, 0xF3, 0xF4, 
  0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFA, 0xFB, 0xFC, 0xFD, 0xFD, 0xFE, 0xFE, 
  0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFD, 
  0xFD, 0xFC, 0xFB, 0xFA, 0xFA, 0xF9, 0xF8, 0xF6, 0xF5, 0xF4, 0xF3, 0xF1, 
  0xF0, 0xEE, 0xED, 0xEB, 0xEA, 0xE8, 0xE6, 0xE4, 0xE2, 0xE0, 0xDE, 0xDC, 
  0xDA, 0xD7, 0xD5, 0xD3, 0xD0, 0xCE, 0xCB, 0xC9, 0xC6, 0xC4, 0xC1, 0xBE, 
  0xBC, 0xB9, 0xB6, 0xB3, 0xB0, 0xAD, 0xAA, 0xA7, 0xA5, 0xA2, 0x9E, 0x9B, 
  0x98, 0x95, 0x92, 0x8F, 0x8C, 0x89, 0x86, 0x83, 0x80, 0x7D, 0x7A, 0x77, 
  0x74, 0x71, 0x6E, 0x6B, 0x68, 0x65, 0x62, 0x5E, 0x5B, 0x59, 0x56, 0x53, 
  0x50, 0x4D, 0x4A, 0x47, 0x44, 0x42, 0x3F, 0x3C, 0x3A, 0x37, 0x35, 0x32, 
  0x30, 0x2D, 0x2B, 0x29, 0x26, 0x24, 0x22, 0x20, 0x1E, 0x1C, 0x1A, 0x18, 
  0x16, 0x15, 0x13, 0x12, 0x10, 0x0F, 0x0D, 0x0C, 0x0B, 0x0A, 0x08, 0x07, 
  0x06, 0x06, 0x05, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 
  0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x0D, 0x0F, 0x10, 0x12, 0x13, 0x15, 
  0x16, 0x18, 0x1A, 0x1C, 0x1E, 0x20, 0x22, 0x24, 0x26, 0x29, 0x2B, 0x2D, 
  0x30, 0x32, 0x35, 0x37, 0x3A, 0x3C, 0x3F, 0x42, 0x44, 0x47, 0x4A, 0x4D, 
  0x50, 0x53, 0x56, 0x59, 0x5B, 0x5E, 0x62, 0x65, 0x68, 0x6B, 0x6E, 0x71, 
  0x74, 0x77, 0x7A, 0x7D

};
IntervalTimer PIT = IntervalTimer();
uint16_t audioBufferFirst[MAX_BUFFER_SIZE];
uint16_t audioBufferLast[MAX_BUFFER_SIZE];
uint8_t bufferLength;
uint8_t sampleSize;
uint8_t sampleCounter = 0;
uint8_t led = 13;
uint8_t counter = 0;
uint8_t wait_for_SOF = 1;
uint8_t readFirstBuffer = 1;
unsigned short phase;
unsigned short tuning;
float freq;
bool active=false;
void initStuff(){
	sampleCounter = 0;
	sampleSize = 2; //2 bytes per sample
	bufferLength = 16; //SAMPLING_FREQ/1000 samples per packet
	uint8_t i;
	for (i=0;i<MAX_BUFFER_SIZE;i++){
		audioBufferFirst[i] = 0x0000;
	}
}
// void setup() {
	pinMode(led,OUTPUT);
	initStuff();
	Audio.begin();
}

void loop() {
	if (active){
		if(!Audio.getAlternateSetting()){
			//PIT.end();
			active=false;
			blink();
			blink();
		}else{
			if (wait_for_SOF){
				sendBuffer();
				sampleCounter = 0;
				wait_for_SOF = 0;
				freq = freq_table[map(analogRead(NOTE_POT),0,1024,0,84)];
				tuning = 65536*freq/SAMPLING_FREQ;
			}else doAudioStuffISR();
		}
	} else {
		if (Audio.getAlternateSetting()){
			active=true;
			blink();
		}
	}
}

void sendBuffer(){
	//if (readFirstBuffer) Audio.sendAudio(audioBufferFirst,bufferLength*sampleSize);
	//else 
	Audio.sendAudio(audioBufferLast,bufferLength*sampleSize);
	//Audio.clearSOF();
}

void doAudioStuffISR(){
	if (sampleCounter==bufferLength) {
		wait_for_SOF = 1;
		return;
	}
	phase+=tuning;
	uint8_t temp = phase>>8;
	//if (readFirstBuffer) { 
	audioBufferLast[sampleCounter++] = (sineTable[temp]-0x80); //readFirstBuffer=0; }
	//else { audioBufferFirst[sampleCounter++] = (sineTable[counter++]-0x80)<<3; readFirstBuffer=1; };
}
void blink(){
	digitalWrite(led,HIGH);
	delay(50);
	digitalWrite(led,LOW);
	delay(50);
}